//
//  server-kitura.swift
//  PenTest
//
//  Created by Martin Leopold on 17.11.17.
//

import Foundation
import Kitura
import KituraWebSocket

class BroadcastService: WebSocketService {
    private var connections = [String: WebSocketConnection]()
    
    func connected(connection conn: WebSocketConnection) {
        connections[conn.id] = conn
        print("WEBSOCKET connection from: \(conn.request.remoteAddress)");
        conn.send(message: "Welcome to PenTest WebSocket server!")
    }
    
    func disconnected(connection conn: WebSocketConnection, reason: WebSocketCloseReasonCode) {
        connections.removeValue(forKey: conn.id)
        print("WEBSOCKET client disconected with reason \(reason): \(conn.request.remoteAddress)");
    }
    
    func received(message: Data, from: WebSocketConnection) {
        // ignore
    }
    
    func received(message: String, from: WebSocketConnection) {
        // ignore
    }
    
    func broadcast(message msg: String) {
        for (_, conn) in connections {
            conn.send(message: msg)
        }
    }
}

func getJSONString<T: Encodable>(fromEncodable encodable: T) -> String {
    let jsonData = try? JSONEncoder().encode(encodable)
    let jsonString = String(data: jsonData!, encoding: .utf8)!
    return jsonString
}

class WebSocketServer_Kitura {
    var service = BroadcastService()
    
    init() {
        // Create a new router
        let router = Router()
        
        // Static content
        router.get("/", middleware: StaticFileServer(path: "./public"))
        
        // WebSocket Endpoint
        WebSocket.register(service: service, onPath: "/")
        
        // Add an HTTP server and connect it to the router
        Kitura.addHTTPServer(onPort: 8080, with: router)
        
        // Start the Kitura runloop (this call never returns)
        Kitura.start()
    }
    
    // broadcast a message to all connected clients
    func broadcast(message msg: String) {
        service.broadcast(message: msg)
    }
    
    func broadcast<T: Encodable>(encodable: T) -> String {
        let jsonString = getJSONString(fromEncodable: encodable)
        service.broadcast(message: jsonString)
        return jsonString
    }
}
